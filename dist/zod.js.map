{"version":3,"sources":["../src/zod/index.ts","../src/config.ts","../src/error.ts","../src/validate.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * ## HexaURL validation extension for the Zod schema\n *\n * This module adds a new hexaurl method to the Zod String schema.\n * This method validates that a string is in the HexaURL format, based on the specified byteSize and config.\n *\n * @remarks\n * - The config parameter is optional and can be customized as needed.\n * - The default value of byteSize is 16 (can contain up to 21 characters).\n *\n * @example\n * // Basic HexaURL validation\n *\n * import { z } from \"zod\";\n * import \"hexaurl-validate/zod\"; // Ensure the module is imported to use the hexaurl method\n *\n * const schema = z.string().hexaurl();\n *\n * schema.parse(\"abc-123\"); // ✅ OK\n *\n * try {\n *   schema.parse(\"invalid-hexaurl!\");\n * } catch (err) {\n *   console.log(err.message); // ❌ Invalid HexaURL format\n * }\n *\n * @example\n * // Combine with other Zod validations with Config\n *\n * import { z } from \"zod\";\n * import { createConfig } from \"hexaurl-validate\";\n * import \"hexaurl-validate/zod\";\n *\n * const config = createConfig({ minLength: 5 });\n *\n * const customSchema = z.string()\n *   .regex(/[0-9]$/, {\n *     message: \"The string must end with a digit\",\n *   })\n *   .hexaurl(config, 8) // 8-byte HexaURL can contain up to 10 characters\n *   .transform(hexaurl => `https://example.com/${hexaurl}`);\n *\n * const result = customSchema.safeParse(\"abc-123\");\n * console.log(result.success); // true\n * console.log(result.data.href); // https://example.com/abc-123\n * console.log(result.data.pathname); // /abc-123\n *\n * @module\n */\n\nimport { ZodString, ZodEffects } from \"zod\";\nimport { validate, Config, HexaUrlError } from \"../index\";\n\ndeclare module \"zod\" {\n  interface ZodString {\n    hexaurl(\n      config?: Config,\n      byteSize?: number,\n    ): ZodEffects<ZodString, string, string>;\n  }\n}\n\nZodString.prototype.hexaurl = function (\n  config: Config = Config.create(),\n  byteSize: number = 16,\n) {\n  // The type returned by superRefine is ZodEffects<... > but treated as this by casting\n  return this.superRefine((value: string, ctx) => {\n    try {\n      validate(value, config, byteSize);\n    } catch (err) {\n      if (err instanceof HexaUrlError) {\n        ctx.addIssue({\n          code: \"custom\",\n          message: err.message + ` (code: ${err.code})`,\n        });\n      } else {\n        ctx.addIssue({\n          code: \"custom\",\n          message: \"Unknown error during HexaURL validation\",\n        });\n      }\n    }\n  });\n};\n","/** Valid options for identifier composition */\nexport enum Composition {\n  /** Letters and digits */\n  Alphanumeric,\n  /** Letters, digits and hyphen */\n  AlphanumericHyphen,\n  /** Letters, digits and underscore */\n  AlphanumericUnderscore,\n  /** Letters, digits, hyphen and underscore */\n  AlphanumericHyphenUnderscore,\n}\n\n/** Rules for how delimiters can be used */\nexport interface DelimiterRules {\n  allowLeadingTrailingHyphens: boolean;\n  allowLeadingTrailingUnderscores: boolean;\n  allowConsecutiveHyphens: boolean;\n  allowConsecutiveUnderscores: boolean;\n  allowAdjacentHyphenUnderscore: boolean;\n}\n\n/** Optional configuration parameters */\nexport interface ConfigOptions {\n  minLength?: number | null;\n  maxLength?: number | null;\n  composition?: Composition;\n  delimiter?: DelimiterRules | null;\n}\n\n/** Configuration for validation rules */\nexport class Config {\n  private static readonly DEFAULT_MIN_LENGTH = 3;\n\n  constructor(\n    public readonly minLength: number | null = Config.DEFAULT_MIN_LENGTH,\n    public readonly maxLength: number | null = null,\n    public readonly composition: Composition = Composition.AlphanumericHyphen,\n    public readonly delimiter: DelimiterRules | null = null,\n  ) {\n    this.validate();\n  }\n\n  /** Creates a new Config from options */\n  static create(options: ConfigOptions = {}): Config {\n    return new Config(\n      options.minLength ?? Config.DEFAULT_MIN_LENGTH,\n      options.maxLength ?? null,\n      options.composition ?? Composition.AlphanumericHyphen,\n      options.delimiter ?? null,\n    );\n  }\n\n  /** Creates a minimal config with relaxed rules */\n  static minimal(): Config {\n    return new Config(\n      null,\n      null,\n      Composition.AlphanumericHyphenUnderscore,\n      createAllowedDelimiterRules(),\n    );\n  }\n\n  /** Validates the config values */\n  private validate(): void {\n    if (\n      this.minLength !== null &&\n      this.maxLength !== null &&\n      this.minLength > this.maxLength\n    ) {\n      throw new Error(\"Minimum length cannot be greater than maximum length\");\n    }\n  }\n\n  toString = (): string =>\n    `Config(minLength=${this.minLength}, maxLength=${this.maxLength}, composition=${this.composition}, delimiter=${JSON.stringify(this.delimiter)})`;\n}\n\n/** Creates delimiter rules with specified options */\nexport const createDelimiterRules = (\n  o: Partial<DelimiterRules> = {},\n): DelimiterRules => ({\n  allowLeadingTrailingHyphens: false,\n  allowLeadingTrailingUnderscores: false,\n  allowConsecutiveHyphens: false,\n  allowConsecutiveUnderscores: false,\n  allowAdjacentHyphenUnderscore: false,\n  ...o,\n});\n\n/** Creates delimiter rules with all options enabled */\nexport const createAllowedDelimiterRules = (): DelimiterRules => ({\n  allowLeadingTrailingHyphens: true,\n  allowLeadingTrailingUnderscores: true,\n  allowConsecutiveHyphens: true,\n  allowConsecutiveUnderscores: true,\n  allowAdjacentHyphenUnderscore: true,\n});\n\n/** Creates a new Config with provided options */\nexport const createConfig = (o: ConfigOptions = {}): Config => Config.create(o);\n","/** Custom error class for HexaURL validation errors */\nexport class HexaUrlError extends Error {\n  constructor(\n    message: string,\n    /** Error code identifying the specific validation failure */\n    public readonly code: HexaUrlErrorCode,\n  ) {\n    super(message);\n  }\n}\n\n/** Enum of possible HexaURL validation error codes */\nexport enum HexaUrlErrorCode {\n  /** String exceeds maximum length */\n  StringTooLong,\n  /** String is shorter than minimum length */\n  StringTooShort,\n  /** Byte array exceeds maximum length */\n  BytesTooLong,\n  /** Byte array is shorter than minimum length */\n  BytesTooShort,\n  /** Contains invalid characters */\n  InvalidCharacter,\n  /** Configuration is invalid */\n  InvalidConfig,\n  /** Length is invalid for encoding type */\n  InvalidLength,\n  /** Has hyphens at start/end when not allowed */\n  LeadingTrailingHyphen,\n  /** Has underscores at start/end when not allowed */\n  LeadingTrailingUnderscore,\n  /** Contains consecutive hyphens when not allowed */\n  ConsecutiveHyphens,\n  /** Contains consecutive underscores when not allowed */\n  ConsecutiveUnderscores,\n  /** Has adjacent hyphen+underscore when not allowed */\n  AdjacentHyphenUnderscore,\n}\n","import {\n  Config,\n  Composition,\n  DelimiterRules,\n  createDelimiterRules,\n} from \"./config\";\nimport { HexaUrlError, HexaUrlErrorCode } from \"./error\";\n\n// Precompiled RegExp patterns for efficient text validation\nconst PATTERNS = {\n  ALPHANUMERIC: /^[0-9A-Za-z]+$/,\n  ALPHANUMERIC_HYPHEN: /^[0-9A-Za-z-]+$/,\n  ALPHANUMERIC_UNDERSCORE: /^[0-9A-Za-z_]+$/,\n  ALPHANUMERIC_HYPHEN_UNDERSCORE: /^[0-9A-Za-z\\-_]+$/,\n};\n\n/**\n * Calculates the length of the decoded string based on the input byte count.\n * Uses SIXBIT 4:3 ratio.\n */\nconst calcStrLen = (n: number): number => (n * 4) / 3;\n\n/**\n * Validates a HexaURL string against configurable rules.\n *\n * ---\n *\n * Performs validation checks in the following order:\n * 1. Length constraints (min/max) - throws InvalidLength error if minLength is greater than calculated max length\n * 2. Character composition based on identifier type\n * 3. Delimiter rules for hyphens and underscores\n *\n * ---\n *\n * Default configuration:\n * - Minimum length: 3 characters\n * - Maximum length: Based on byteSize parameter (16 bytes = 21 characters)\n * - Allowed chars: Alphanumeric with hyphens only\n * - Strict delimiter rules:\n *   - No leading/trailing delimiters\n *   - No consecutive delimiters\n *   - No adjacent hyphen-underscore pairs\n *\n * ---\n *\n * @param input The HexaURL string to validate\n * @param config Optional configuration for validation rules\n * @param byteSize The target byte array size after encoding (default 16)\n *\n * @throws {HexaUrlError} If any validation rule is violated, with specific error code and message\n */\nexport const validate = (\n  input: string,\n  config: Config = Config.create(),\n  byteSize: number = 16,\n): void => {\n  const len = input.length;\n\n  // Calculate effective maximum length\n  const effectiveMax =\n    config.maxLength !== null\n      ? Math.min(config.maxLength, Math.floor(calcStrLen(byteSize)))\n      : Math.floor(calcStrLen(byteSize));\n\n  // Check if effectiveMax is less than minLength\n  if (config.minLength !== null && effectiveMax < config.minLength) {\n    throwError(\n      HexaUrlErrorCode.InvalidConfig,\n      `Maximum length (${effectiveMax}) cannot be less than minimum length (${config.minLength})`,\n    );\n  }\n\n  // Check minimum length\n  if (config.minLength !== null && len < config.minLength) {\n    throwError(\n      HexaUrlErrorCode.StringTooShort,\n      `Too short: minimum length is ${config.minLength}`,\n    );\n  }\n\n  // Check maximum length\n  if (len > effectiveMax) {\n    throwError(\n      HexaUrlErrorCode.StringTooLong,\n      `Too long: maximum length is ${effectiveMax}`,\n    );\n  }\n\n  // Character validation based on identifier composition\n  const [pattern, allowedChars] = getPatternForComposition(config.composition);\n  !pattern.test(input) &&\n    throwError(\n      HexaUrlErrorCode.InvalidCharacter,\n      `Invalid character: only ${allowedChars} are allowed`,\n    );\n\n  // Delimiter rules validation\n  validateDelimiters(input, config.delimiter ?? createDelimiterRules());\n};\n\n/**\n * Maps identifier composition to corresponding RegExp pattern.\n * Patterns are precompiled for performance.\n */\nconst getPatternForComposition = (\n  composition: Composition,\n): [RegExp, string] => {\n  switch (composition) {\n    case Composition.Alphanumeric:\n      return [PATTERNS.ALPHANUMERIC, \"alphabets or numbers\"];\n    case Composition.AlphanumericHyphen:\n      return [PATTERNS.ALPHANUMERIC_HYPHEN, \"alphabets, numbers, or hyphens\"];\n    case Composition.AlphanumericUnderscore:\n      return [\n        PATTERNS.ALPHANUMERIC_UNDERSCORE,\n        \"alphabets, numbers, or underscores\",\n      ];\n    case Composition.AlphanumericHyphenUnderscore:\n      return [\n        PATTERNS.ALPHANUMERIC_HYPHEN_UNDERSCORE,\n        \"alphabets, numbers, hyphens, or underscores\",\n      ];\n  }\n};\n\n/**\n * Validates all delimiter-related rules against input string.\n * Checks both positional (leading/trailing) and sequential (consecutive/adjacent) rules.\n */\nconst validateDelimiters = (input: string, rules: DelimiterRules): void => {\n  // Check leading/trailing delimiters\n  !rules.allowLeadingTrailingHyphens &&\n    (input.startsWith(\"-\") || input.endsWith(\"-\")) &&\n    throwError(\n      HexaUrlErrorCode.LeadingTrailingHyphen,\n      \"Cannot start or end with hyphens (-)\",\n    );\n\n  !rules.allowLeadingTrailingUnderscores &&\n    (input.startsWith(\"_\") || input.endsWith(\"_\")) &&\n    throwError(\n      HexaUrlErrorCode.LeadingTrailingUnderscore,\n      \"Cannot start or end with underscores (_)\",\n    );\n\n  // Check consecutive delimiters\n  !rules.allowConsecutiveHyphens &&\n    input.includes(\"--\") &&\n    throwError(\n      HexaUrlErrorCode.ConsecutiveHyphens,\n      \"Cannot contain consecutive hyphens (--)\",\n    );\n\n  !rules.allowConsecutiveUnderscores &&\n    input.includes(\"__\") &&\n    throwError(\n      HexaUrlErrorCode.ConsecutiveUnderscores,\n      \"Cannot contain consecutive underscores (__)\",\n    );\n\n  // Check adjacent different delimiters\n  !rules.allowAdjacentHyphenUnderscore &&\n    (input.includes(\"-_\") || input.includes(\"_-\")) &&\n    throwError(\n      HexaUrlErrorCode.AdjacentHyphenUnderscore,\n      \"Cannot contain adjacent hyphen and underscore combinations (-_ or _-)\",\n    );\n};\n\n/** Helper function to throw typed validation errors */\nconst throwError = (code: HexaUrlErrorCode, message: string): never => {\n  throw new HexaUrlError(message, code);\n};\n\n/**\n * Performs a fast pre-validation safety check for HexaURL encoding to prevent errors and conflicts.\n *\n * Efficiently validates only string length constraints and ASCII character restriction, skipping full validation.\n *\n * Optimized for rapid pre-screening before search operations or other cases where generating an invalid\n * HexaURL temporarily is acceptable. The lighter validation makes it ideal for high-performance lookup scenarios\n * where a full validation pass is not required.\n *\n * ---\n *\n * @param input The string to check\n * @param byteSize The target byte array size after encoding (default 16)\n * @returns boolean indicating if the string is safe to encode\n */\nexport const isEncodingSafe = (input: string, byteSize: number = 16): boolean =>\n  input.length <= calcStrLen(byteSize) && /^[\\x00-\\x7F]*$/.test(input);\n"],"mappings":"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","names":[]}